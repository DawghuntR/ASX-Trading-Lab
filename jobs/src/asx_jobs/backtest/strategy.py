"""Base Strategy Interface.

Defines the interface that all trading strategies must implement.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from typing import Any


class SignalType(Enum):
    """Strategy signal types."""

    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


@dataclass
class StrategySignal:
    """Signal generated by a strategy.

    Attributes:
        signal_type: Type of signal (buy, sell, hold).
        instrument_id: Instrument to trade.
        symbol: Instrument symbol for logging.
        price: Current price at signal generation.
        quantity: Suggested quantity (optional, engine may override).
        reason: Human-readable reason for the signal.
        metadata: Additional signal metadata.
    """

    signal_type: SignalType
    instrument_id: int
    symbol: str
    price: float
    quantity: int | None = None
    reason: str | None = None
    metadata: dict[str, Any] | None = None


@dataclass
class StrategyConfig:
    """Base configuration for strategies."""

    name: str
    version: str = "1.0.0"
    description: str | None = None


class Strategy(ABC):
    """Base class for all trading strategies.

    Strategies receive daily price data and generate trading signals.
    They are stateless - the engine manages position state.
    """

    def __init__(self, config: StrategyConfig) -> None:
        """Initialize strategy.

        Args:
            config: Strategy configuration.
        """
        self.config = config

    @property
    def name(self) -> str:
        """Strategy name."""
        return self.config.name

    @property
    def version(self) -> str:
        """Strategy version."""
        return self.config.version

    @property
    def description(self) -> str | None:
        """Strategy description."""
        return self.config.description

    @abstractmethod
    def get_parameters(self) -> dict[str, Any]:
        """Get strategy parameters for persistence.

        Returns:
            Dictionary of parameter name to value.
        """
        ...

    @abstractmethod
    def on_bar(
        self,
        instrument_id: int,
        symbol: str,
        bar: dict[str, Any],
        history: list[dict[str, Any]],
        position: dict[str, Any] | None,
    ) -> StrategySignal | None:
        """Process a single bar and optionally generate a signal.

        This method is called once per instrument per day. The strategy
        should analyze the current bar and historical data to decide
        whether to generate a trading signal.

        Args:
            instrument_id: Instrument database ID.
            symbol: Instrument ticker symbol.
            bar: Current day's OHLCV bar with keys:
                - trade_date: Date string (YYYY-MM-DD)
                - open: Opening price
                - high: High price
                - low: Low price
                - close: Closing price
                - volume: Trading volume
            history: List of previous bars (most recent first), not including current bar.
            position: Current position info if held, or None:
                - quantity: Number of shares
                - entry_price: Average entry price
                - entry_date: Date position was opened
                - unrealized_pnl: Current unrealized P&L

        Returns:
            StrategySignal if action should be taken, None otherwise.
        """
        ...

    def on_start(self, start_date: str, end_date: str) -> None:
        """Called before backtest starts.

        Override to perform any initialization.

        Args:
            start_date: Backtest start date.
            end_date: Backtest end date.
        """
        pass

    def on_end(self) -> None:
        """Called after backtest ends.

        Override to perform any cleanup.
        """
        pass
